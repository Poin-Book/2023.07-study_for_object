# 원칙의 함정
> 작성자:

## 목차



## 디미터 법칙

→ 결합도와 관련된 원칙

- 결합도가 문제가 되는 경우
    - 객체의 내부 구조가 외부로 노출되는 경우

<br>

```java
IntStream.of(1,15,20,3,9).filter(x->x>10).distinct().count();
```

디미터 법칙은 “오직 하나의 도트(.)만을 사용하라”라는 말로 요약되기도 함

*그렇다면 위 예제는 디미터 법칙을 위반 했을까?*

→ 위반하지 않았다

- of, filter, distinct, count는 모두 동일한 클래스의 인스턴스를 반환
    - IntStream의 인스턴스를 다른 IntStream으로 반환

→ 즉, 객체를 둘러싸고 있는 캡슐을 그대로 유지됨

<br>

<br>

- 하나 이상의 도트 사용이 디미터 법칙 위반은 아님
- 객체 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디머터 법칙을 준수한 것

<br>

<br>

<br>

### 결합도와 응집도의 충돌

객체의 응집도를 높일 수 있는 효과적인 방법

→ **위임 메서드를 통해 객체 내부 구조를 감추는 것**

ex) **영화관**이 **관객** 내부에 포함된 **Bag**에 대해 질문한 후 변환된 결과를 이용해 **Bag**의 상태를 변경하는 것은 캡슐화를 위반하기 때문에 위 상태를 변경하는 모든 코드를 **관객**에게 **위임**하는 것

→ 이렇게 한다면 **관객은 상태와 함께 상태를 조작하는 행동** 또한 포함하기에 **응집도가 높아짐**

<br>

<br>

- 모든 상황에서 위임 메서드를 추가하면 오히려 응집도가 낮아질 수 있음
    - 객체는 자신과 상관없는 책임까지 떠안음

### 따라서, “묻지 말고 시켜라”, “디미터 법칙”을 무작정 따르면 응집도가 낮은 객체로 넘칠 수 있음

ex) **isSatisfiedBy** 메서드는 **Screening**에게 질의한 상영 시간을 이용해 할인 여부를 결정한다.

→ **Screening**이 ****할인 여부를 결정한다면?

- 할인 조건을 판단하는 책임이 생김
- **Screening**의 본질적인 책임은 영화를 예매하는 것

→  **Screening** 자신과 상관없는 책임을 가져 응집도가 낮아지는 결과

<br>

<br>

디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료구조인지에 달려 있다

- 묻는 대상이 객체라면 디미터 법칙을 따르는 것이 좋음
- 묻는 대상이 자료구조라면 당연히 내부를 노출해야함
    - 디미터 법칙을 적용할 필요가 없음

<br>

<br>

객체에게 가끔씩은 물어야 한다.

소프트웨어 설계에 법칙은 존재하지 않으면 원칙을 맹신하면 안된다.

### 설계는 트레이드 오프의 산물이기 때문이다.

소프트웨어 설계의 몇 안되는 법칙은 “경우에 따라 다르다”이다
