# 제목

> 작성자: 심세원


## 목차
- [캡슐화](#캡슐화)
- [응집도, 결합도](#응집도-결합도)
- [결론](#결론)
  <br><br>
  데이터 중심 설계, 책임 중심 설계의 비교를 위해 **캡슐화, 응집도, 결합도를 사용**

## 캡슐화

상태와 행동을 객체 안에 모으는 이유는 객체 내부 구현을 외부로 감추기 위해서 임

구현 : **나중에 변경될 가능성이 높은 것**

인터페이스: **상대적으로 안정적인 부분**

 → 객체 지향이 강력한 이유, 변경에 잘 대응 가능

<br>

### 구현과 인터페이스를 분리, 외부에서는 인터페이스에만 의존하도록 조절하기

→ 객체 설계를 위한 가장 기본적인 아이디어

→ 불안정한 구현 세부 사항을 안정적인 인터페이스 뒤로 캡슐화 하기

<br>

캡슐화란?

> 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
> 

그렇다면, 무엇을 캡슐화 해야 하는가?

**→ 변경될 수 있는 어떤 것이라도 캡슐화 해야 함**

## 응집도, 결합도

응집도

> 모듈에 포함된 내부 요소들이 연관되어 있는 정도
> 

| 낮은 응집도 | 높은 응집도 |
| --- | --- |
|  모듈 내 요소가 서로 다른 목적 추구 | 모듈 내 요소가 하나의 목적을 추구 |

객체, 클래스에 얼마나 관련 높은 책임을 할당했는지를 나타냄

<br>

결합도 (의존성의 정도)

> 다른 모듈에 대해 얼마나 많은 지식을 가지고 있는지 나타내는 척도
> 

| 낮은 결합도 | 높은 결합도 |
| --- | --- |
| 다른 모듈에 대해 꼭 필요한 지식만 말고 있음 | 다른 모듈에 대해 자세한 부분까지 알고 있음 |

객체, 클래스가 협력에 필요한 적절한 수준의 관계만 유지하고 있는 가를 나타냄

<br>

일반적으로 좋은 설계란?

**높은 응집도와 낮은 결합도 →** 변경에 대응하기 쉽기 때문

<br><br>

***변경의 관점에서 응집도와 결합도***

응집도

> **변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도**
> 

| 높은 응집도 | 낮은 응집도 |
| --- | --- |
| 하나의 변경을 수용하기 위해 모듈 전체가 변경됨 | 하나의 변경을 수용하기 위해 모듈 일부가 변경됨 |
| 하나의 변경을 수용하기 위해 모듈 하나만 변경됨 | 하나의 변경을 수용하기 위해 모듈 여러 개가 변경됨 |

응집도가 높을수록 변경의 대상과 범위가 명확해짐

→ 오직 하나의 모듈만 수정하면 됨

<br>

결합도

> **한 모듈이 변결되기 위해 다른 모듈의 변경을 요구하는 정도**
> 

| 높은 결합도 | 낮은 결합도 |
| --- | --- |
| 하나의 모듈을 수정할 때, 변경해야 하는 모듈이 많음 | 하나의 모듈을 수정할 때, 변경해야 하는 모듈이 적음 |

결합도가 높을 수록 함께 변경해야 하는 모듈의 수가 늘어남

→ 변경하기 어려움

**클래스의 구현이 아닌, 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있음**

<br><br>

변경될 확률이 아주 적은 안정적인 모델(표준 라이브러리, 성숙 단계의 프레임 워크)에 의존하는 경우에는 결합도가 높아도 상관 없음

직접 작성한 코드에 대해서는 결합도가 낮아야함

## 결론

**캡슐화의 정도에 따라, 응집도와 결합도의 정도가 달라진다.**

따라서,

높은 응집도, 낮은 결합도를 위해 캡슐화를 향상 시키기 위해 노력해야 한다.
