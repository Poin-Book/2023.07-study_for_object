# 영화 예매 시스템
> 작성자: 고민정

## 목차
* 영화 예매 시스템
    * 요구사항 살펴보기
* 객체지향 프로그래밍을 향해
    * 협력, 객체, 클래스
    * 도메인의 구조를 따르는 프로그램 구조
    * 클래스 구현
    * 자율적인 객체
    * 프로그래머의 자유
    * 협력의 짧은 요약   
    
___
### 영화 예매 시스템
#### (1) 요구사항 살펴보기
**'영화'** 와 **'상영**'이라는 용어를 구분하여 사용한다.
사용자가 실제로 예매하는 대상은 영화가 아니라 상영이기 때문에 두 용어 차이는 중요하다.  
||내용|설명|
|------|---|---|
|영화|영화에 대한 기본 정보|제목, 상영시간, 가격 정보 ... |
|상영|실제로 관객들이 영화를 관람하는 사건|상영 일자, 시간, 순번 ...|

특정 조건을 만족하면 예매자는 요금을 할인받을 수 있다. 
할인액을 결정하는 두 가지 조건 **'할인 조건'** 과 **'할인 정책'** 이 있다.
**'할인 조건'** 은 **순서 조건**과 **기간 조건**으로 나뉜다.

|할인 조건|내용|예시|
|------|---|---|
|순서 조건|상영 순번을 이용해 할인 여부를 결정하는 규칙|순번이 4인 경우  4번째 상영 영화를 예매한 사람에게 할인 |
|기간 조건|영화 상영 시작 시간을 이용해 할인여부 결정 (요일, 시작 시간, 종료 시간)|매주 월요일(요일) 오전 10시부터(시작 시간) 오후 1시(종료 시간) 사이에 상영된 모든 영화를 할인|

**'할인 정책'** 은 **금액 할인 정책** 과 **비율 할인 정책** 으로 나뉜다.

|할인 정책|내용|예시|
|------|---|---|
|금액 할인 정책|예매 요금에서 일정 금액을 할인|영화가격 : 9000, 할인 금액 : 800, 총 예매가 : 8200|
|비율 할인 정책|정가에서 일정 비율의 요금을 할인|영화 가격 : 9000, 비율 할인 : 10%, 총 예매가 8100|

**'할인 정책'** 은 영화별로 하나의 할인만 받을 수 있다. 
하지만 **'할인 조건'** 은 다수의 할인 조건을 함께 지정할 수 있다. (표 2.1 참고)


_할인을 적용하기 위해서는 할인 조건과 할인 정책을 함께 조합해서 사용한다._
1. 사용자의 예매 정보가 할인 조건 중 하나라도 만족하는지 검사한다.<br/>
1-1. 할인 조건을 만족할 경우 할인 정책을 이용해 할인 요금을 계산한다.<br/>
1-2. 할인 정책은 적용돼 있지만 할인 조건을 만족하지 못하는 경우 요금을 할인하지 않는다.
2. 아예 할인 정책이 적용돼 있지 않은 경우에는 요금을 할인하지 않는다.
* 결과에 포함되어야 하는 내용
사용자가 예매를 완료하면 생성되어야 하는 정보는
    * 제목
    * 상영 정보 (날짜, 시간)
    * 인원
    * 정가
    * 결제 금액 (정가 - 할인 금액)
 ---
### 객체지향 프로그래밍을 향해
#### (1) 협력, 객체, 클래스
> class : 공통적인 상태와 행동을 공유하는 객체들을 추상화 한 것

* 객체지향 프로그래밍에서 집중해야하는 두 가지
    1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라
    2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라
---
#### (2) 도메인의 구조를 따르는 프로그램 구조
> 도메인 (domain) : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 <br/> ex) 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하려는 것

요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 연결된다.
* 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다. 
(프로그램의 구조를 이해하고 예상하기 쉽개 만들어야 하기 때문)
---
#### (3) 클래스 구현
(p43 코드 참고)<br/>
주목할 점은 **인스턴스 변수의 가시성은 private이고 매서드의 가시성은 public** 이다.<br/>
이는 클래스의 경계를 구분 짓는 것이다.<br/>
##### 클래스의 외부와 내부를 구분해야하는 이유는 무엇일까?
경계의 명확성이 객체의 자율성을 보장하기 때문이다. (프로그래머에게 구현의 자유를 제공)

---
#### (4) 자율적인 객체
중요한 사실
1. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재
2. 객체는 스스로 판단하고 행동하는 자율적인 존재
>Encapsulation : data, data를 활용하는 함수를 capsul(=class) 안에 함께 두는 것<br/>
access control(접근 제어) : 외부에서의 접근을 통제<br/>
access modifier(접근 수정자) : 접근 제어를 위한 것 (private, public, protected)

객체가 자율적인 존재로 있기 위해서는 외부의 간섭을 최소화해야한다.


Encapsulation과 접근 제어는 객체를 두 부분으로 나눈다.
|Encapsulation & 접근 제어|내용|
|------|---|
|public interface|외부에서 접근 가능한 부분|
|implementation|외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분|
---
#### (5) 프로그래머의 자유
* 프로그래머의 역할

    |역할|내용|목표|
    |------|---|---|
    |클래스 작성자|새로운 데이터 타입을 프로그램에 추가|클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨김|
    |클라이언트 프로그래머|클래스 작성자가 추가한 데이터 타입을 사용|필요한 클래스들을 엮어 앱을 빠르고 안정적으로 구축|
    > 구현 은닉(implementation hiding) : 클라이언트 프로그래머가 숨겨놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 내부 구현을 마음대로 변경할 수 있음
    
    클라이언트 프로그래머가 private 속성이나 메서드에 접근하려고 시도하면 컴파일러는 오류를 낸다.
* 장점
  * 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있다.
  * 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부구현을 마음대로 변경 가능

---
#### (6) 협력의 짧은 요약  
객체의 내부 상태는 외부에서 접근하지 못한다. 대신 외부에 공개하는 public interface를 통해 내부 상태에 접근할 수 있도록 서용한다.
> 요청(request) : 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청
응답(response) : 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답
method : 수신된 메시지를 처리하기 위한 자신만의 방법
